package uk.gov.dft.ais.decode

import org.apache.spark.sql.{SparkSession}
import org.apache.spark.sql.functions.udf
import org.apache.spark.sql.functions.{min, max}
import scala.math.{abs, pow}
import uk.gov.dft.ais.decode.utils.{extractInt, extractString, parseIntWScale,
  stringLength}

// add the dependency
// %addJar file:///Users/willbowditch/projects/ds-ais/decode/aisdecode/target/scala-2.11/aisdecode_2.11-0.1.0.jar

object decode123{
  /**
   * Decode type 5 messages
   * params 0 - read bucket location
   * parms 1 - write bucket location (parquet file)
   */
  def main (args:Array[String]): Unit = {

    // Start a spark context
    val spark = SparkSession
      .builder()
      .appName("AIS-decode-123")
      .master("yarn")
      .config("spark.executor.cores", "2")
      .config("spark.executor.memory", "1g")
      .config("spark.default.parallelism", "36500")
      .config("spark.sql.shuffle.partitions", "36500")
      .getOrCreate()

    // this import has to go after val spark.
    import spark.implicits._

    // Read in the parquet files from first argument location
    val binary_decoded_messages = spark
      .read.format("parquet")
      .load(args(0))




    // Filter just messages 1-3
    // this should be fast as data is partitioned my id
    val msg_123_raw = binary_decoded_messages
      .where($"id" >0 && $"id" < 4)
      // Messages should be 168 bits
      .where(stringLength($"dataBinary") === 168)

    // The section below defines user defined functions to extract data from
    // the binary string generated by rawdecode
    val getRepeat = udf [Option[Int], String] (x => extractInt(x,6,8))

    val getMMSI = udf [Option[Int] , String] (x=> extractInt(x,8,38))

    val getNavigationStatus = udf [Option[String] , String] {x=>
      extractInt(x,38,42) match {
        case Some(0) => Some("Under way using engine")
        case Some(1) => Some("At anchor")
        case Some(2) => Some("Not under command")
        case Some(3) => Some("Restricted manoeuverability")
        case Some(4) => Some("Constrained by her draught")
        case Some(5) => Some("Moored")
        case Some(6) => Some("Aground")
        case Some(7) => Some("Engaged in Fishing")
        case Some(8) => Some("Under way sailing")
        case Some(9) => Some("Reserved for future amendment of Navigational Status for HSC")
        case Some(10) => Some("Reserved for future amendment of Navigational Status for WIG")
        case Some(11) => Some("Reserved for future use")
        case Some(12) => Some("Reserved for future use")
        case Some(13) => Some("Reserved for future use")
        case Some(14) => Some("AIS-SART is active")
        case Some(15) => None //15 is default so null
        case Some(i) => Some(i.toString)
        case None => None
        case _ => None
      }}

    val getROT = udf [Option[Double] , String] {x=>
      // Values between 0 and 708 degrees/min coded by
      // ROTAIS=4.733 * SQRT(ROTsensor) degrees/min
      // where ROTsensor is the Rate of Turn as input by an external Rate of
      // Turn Indicator. ROTAIS is rounded to the nearest integer value.
      // Thus, to decode the field value, divide by 4.733 and then square it.
      // Sign of the field value should be preserved when squaring it,
      // otherwise the left/right indication will be lost.
      val ROT = parseIntWScale(x.slice(42, 50)).getOrElse(0.0)
      val ROTdeg = ROT / 4.733
      val squaredROT = pow(ROTdeg,2)
      // we lost the sign during squaring
      if(ROT <0){Some(-squaredROT)}
        // 128 actually means none
        else if(abs(ROT)==128){None}
        else{Some(squaredROT)}
      }

    val getSOG = udf [Option[Double] , String] {x=>
      // Speed over ground is in 0.1-knot resolution from 0 to 102 knots.
      // Value 1023 indicates speed is not available
      // value 1022 indicates 102.2 knots or higher.
      extractInt(x,50,60) match {
        // If we have some scale by factor, unless 1023, then none!
        case Some(i) => if(i == 1023){None}else{Some(i / 10.0)}
        case None => None
      }
    }

    val getPositionAccuracy = udf [Option[Int] , String] (x=> extractInt(x,60,61))

    val getLongitude = udf [Option[Double] , String] {x=>
      // Longitude is given in in 1/10000 min; divide by 600000.0 to obtain
      // degrees. Values up to plus or minus 180 degrees, East = positive,
      // West \= negative. A value of 181 degrees (0x6791AC0 hex) indicates
      // that longitude is not available and is the default.
      parseIntWScale(x.slice(61,89)) match {
        case Some(i) => {
          val long = i / 600000.0
          if (long == 181){None}else{Some(long)}
        }
        case None => None
      }
    }

    val getLatitude = udf [Option[Double] , String] {x=>
      // Latitude is given in in 1/10000 min; divide by 600000.0 to obtain
      // degrees. Values up to plus or minus 90 degrees, North = positive,
      // South = negative. A value of 91 degrees (0x3412140 hex)
      // indicates latitude is not available and is the default.
      parseIntWScale(x.slice(89,116)) match {
        case Some(i) => {
          val long = i / 600000.0
          if (long == 91){None}else{Some(long)}
        }
        case None => None
      }
    }


    val getCOG = udf [Option[Double] , String] {x=>
      // Course over ground will be 3600 (0xE10) if that data is not available.
      // Relative to true north, to 0.1 degree precision
      extractInt(x,116,128) match {
        case Some(i) => {if(i == 2600){None}else{Some(i/10.0)}}
        case None => None
      }
    }

    val getHDG = udf [Option[Int] , String] {x=>
      // 0 to 359 degrees, 511 = not available.
      extractInt(x,128,137) match {
        case Some(i) => if(i==511){None}else{Some(i)}
        case None => None
      }
    }

    val getTimestamp = udf [Option[Int] , String] {x=>
      // Seconds in UTC timestamp should be 0-59, except for these special values:
      //  60 if time stamp is not available (default)
      //  61 if positioning system is in manual input mode
      //  62 if Electronic Position Fixing System operates in estimated (dead reckoning) mode,
      //  63 if the positioning system is inoperative.
      extractInt(x,137,143) match {
        case Some(i) => if(i > 59){None}else{Some(i)}
        case None => None
      }
    }

    val getManoeuvreIndicator = udf [Option[Int] , String] {x=>
      extractInt(x,143,145)
    }

    // This one isn't used at the moment, but here for reference of bit locations
    val getSpare = udf [Option[Int] , String] (x=> extractInt(x,145,148))

    val getRAIM = udf [Option[Int] , String] (x=> extractInt(x,148,149))

    // This one contains diagnostic info for radio systems, so not processing.
    val getRadioStatus = udf [Option[Int] , String] (x=> extractInt(x,149,168))

    // For each UDF run it on the dataset.
    val processed = msg_123_raw
      .withColumn("decoded_repeate",
        getRepeat(msg_123_raw("dataBinary")))
      .withColumn("decoded_MMSI",
        getMMSI(msg_123_raw("dataBinary")))
      .withColumn("navigation_status",
        getNavigationStatus(msg_123_raw("dataBinary")))
      .withColumn("rate_of_turn",
        getROT(msg_123_raw("dataBinary")))
      .withColumn("speed_over_ground",
        getSOG(msg_123_raw("dataBinary")))
      .withColumn("position_accuracy",
        getPositionAccuracy(msg_123_raw("dataBinary")))
      .withColumn("longitude",
        getLongitude(msg_123_raw("dataBinary")))
      .withColumn("latitude",
        getLatitude(msg_123_raw("dataBinary")))
      .withColumn("course_over_ground",
        getCOG(msg_123_raw("dataBinary")))
      .withColumn("true_heading",
        getHDG(msg_123_raw("dataBinary")))
      .withColumn("timestamp_seconds",
        getTimestamp(msg_123_raw("dataBinary")))
      .withColumn("manoeuvre_indicator",
        getManoeuvreIndicator(msg_123_raw("dataBinary")))
      .withColumn("raim",
        getRAIM(msg_123_raw("dataBinary")))


    // write out to parquet files, location specified in the second argument
    processed.write.parquet(args(1))



  }
}
