package uk.gov.dft.ais.decode

import org.apache.spark.sql.{SparkSession}
import org.apache.spark.sql.functions.udf
import uk.gov.dft.ais.decode.utils.{extractInt, extractString}

// add the dependency
// %addJar file:///Users/willbowditch/projects/ds-ais/scala/aisdecode/target/scala-2.11/aisdecode_2.11-0.1.0-SNAPSHOT.jar

object decode5{
  /**
   * Decode type 5 messages
   * params 0 - read bucket location
   * parms 1 - write bucket location (parquet file)
   */
  def main (args:Array[String]): Unit = {

    // Start a spark context
    val spark = SparkSession
      .builder()
      .appName("AIS-decode-5")
      .master("yarn")
      .config("spark.executor.cores", "2")
      .config("spark.executor.memory", "1g")
      .config("spark.default.parallelism", "36500")
      .config("spark.sql.shuffle.partitions", "36500")
      .getOrCreate()

    // this import has to go after val spark.
    import spark.implicits._

    // Read in the parquet files from first argument location
    val binary_decoded_messages = spark
      .read.format("parquet")
      .load(args(0))

    // Filter just messages 5
    // this should be fast as data is partitioned my id
    //
    //  Note, no bit length checks here as:
    //  "it is fairly common in the wild for this message to have a wrong bit
    //  length (420 or 422). Robust decoders should ignore trailing garbage"
    val msg_5_raw = binary_decoded_messages.where($"id" === 5)

    // The section below defines user defined functions to extract data from
    // the binary string generated by rawdecode
    val getRepeat = udf [Option[Int], String] (x => extractInt(x,6,8))

    val getMMSI = udf [Option[Int] , String] (x=> extractInt(x,8,38))

    val getAISVersion = udf [Option[Int] , String] (x=> extractInt(x,38,40))

    val getIMO = udf [Option[Int] , String] (x=> extractInt(x, 40,70))

    val getCallSign = udf [Option[String] , String] { x=>
      extractString(x, 70,112)
    }

    val getShipName = udf [Option[String] , String] { x=>
      extractString(x, 112,232)
    }

    val getShipType = udf [Option[Int] , String] ( x=> extractInt(x,232,240))

    val getToBow = udf [Option[Int] , String] ( x=> extractInt(x,240,249))

    val getToStern = udf [Option[Int] , String] ( x=> extractInt(x,249,258))

    val getToPort = udf [Option[Int] , String] ( x=> extractInt(x,258,264))

    val getToStarboard = udf [Option[Int] , String] ( x=> extractInt(x,264,270))

    val getPosFixType = udf [Option[Int] , String] ( x=> extractInt(x,270,274))

    val getETAmonth = udf [Option[Int] , String] { x=>
      // 1-12, 0=N/A (default)
      extractInt(x,274,278) match {
        case Some(i) => if(i==0){None}else{Some(i)}
        case None => None
      }
    }

    val getETAday = udf [Option[Int] , String] { x=>
      // 1-31, 0=N/A (default)
      extractInt(x,278,283) match {
        case Some(i) => if(i==0){None}else{Some(i)}
        case None => None
      }
    }
    val getETAhour = udf [Option[Int] , String] { x=>
      // 0-23, 24=N/A (default)
      extractInt(x,283,288) match {
        case Some(i) => if(i==24){None}else{Some(i)}
        case None => None
      }
    }

    val getETAmin = udf [Option[Int] , String] { x=>
      // 0-59, 60=N/A (default)
      extractInt(x,288,294) match {
        case Some(i) => if(i==60){None}else{Some(i)}
        case None => None
      }
    }

    val getDraught = udf [Option[Double] , String] {x=>
      // Meters/10
      extractInt(x,294,302) match {
        case Some(i) => {Some(i / 10)}
        case None => None
      }
    }

    val getDestination = udf [Option[String] , String] {x=>
      extractString(x, 302,422)
    }

    val getDataTerminalReady = udf [Option[Int], String] {x =>
      extractInt(x, 422, 423)
    }

    // For each UDF run it on the dataset.
    val out = msg_5_raw
      .withColumn("decoded_repeate", getRepeat(msg_5_raw("dataBinary")))
      .withColumn("decoded_MMSI", getMMSI(msg_5_raw("dataBinary")))
      .withColumn("aisVersion", getAISVersion(msg_5_raw("dataBinary")))
      .withColumn("IMO", getIMO(msg_5_raw("dataBinary")) )
      .withColumn("callSign", getCallSign(msg_5_raw("dataBinary")))
      .withColumn("shipName", getShipName(msg_5_raw("dataBinary")))
      .withColumn("shipType", getShipType(msg_5_raw("dataBinary")))
      .withColumn("to_bow", getToBow(msg_5_raw("dataBinary")))
      .withColumn("to_stern", getToStern(msg_5_raw("dataBinary")))
      .withColumn("to_port", getToPort(msg_5_raw("dataBinary")))
      .withColumn("to_starboard", getToStarboard(msg_5_raw("dataBinary")))
      .withColumn("epfd", getPosFixType(msg_5_raw("dataBinary")))
      .withColumn("ETA_month", getETAmonth(msg_5_raw("dataBinary")))
      .withColumn("ETA_day", getETAday(msg_5_raw("dataBinary")))
      .withColumn("ETA_hour", getETAhour(msg_5_raw("dataBinary")))
      .withColumn("ETA_min", getETAmin(msg_5_raw("dataBinary")))
      .withColumn("Draught", getDraught(msg_5_raw("dataBinary")))
      .withColumn("Dest", getDestination(msg_5_raw("dataBinary")))
      .withColumn("DTE", getDataTerminalReady(msg_5_raw("dataBinary")))

    // write out to parquet files, location specified in the second argument
    out.write.parquet(args(1))


  }
}
