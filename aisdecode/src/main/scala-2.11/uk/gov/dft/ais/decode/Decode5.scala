package uk.gov.dft.ais.decode

import org.apache.spark.sql.{DataFrame, SparkSession}
import org.apache.spark.sql.functions.udf
import Utils.{extractInt, extractString, parseIntWScale}
import RawClean.removeUnused

object Decode5 {
  /**
   * Decode type 5 messages
   * params 0 - read bucket location
   * parms 1 - write bucket location (parquet file)
   */
  def main (args:Array[String]): Unit = {

    // Start a spark context
    val spark = SparkSession
      .builder()
      .appName("AIS-decode-5")
      .master("yarn")
      .config("spark.executor.cores", "2")
      .config("spark.executor.memory", "1g")
      .config("spark.default.parallelism", "36500")
      .config("spark.sql.shuffle.partitions", "36500")
      .getOrCreate()

    // this import has to go after val spark.
    import spark.implicits._

    // Read in the parquet files from first argument location
    val binary_decoded_messages = spark
      .read.format("parquet")
      .load(args(0))

    // Apply the transformation
    val transformed = transform(spark, binary_decoded_messages)
    val out = removeUnused(spark, transformed)

    // write out to parquet files, location specified in the second argument
    out.write.parquet(args(1))

  }

  def transform(spark: SparkSession, binaryDecodedMessages: DataFrame): DataFrame = {

    // The section below defines user defined functions to extract data from
    // the binary string generated by rawdecode
    val getRepeat = udf [Option[Int], String] (x => extractInt(x,6,8))

    val getMMSI = udf [Option[Int] , String] (x=> extractInt(x,8,38))

    val getais_version = udf [Option[Int] , String] (x=> extractInt(x,38,40))

    val getIMO = udf [Option[Int] , String] (x=> extractInt(x, 40,70))

    val getCallSign = udf [Option[String] , String] { x=>
      extractString(x, 70,112)
    }

    val getShipName = udf [Option[String] , String] { x=>
      extractString(x, 112,232)
    }

    val getShipType = udf [Option[Int] , String] ( x=> extractInt(x,232,240))

    val getToBow = udf [Option[Int] , String] ( x=> extractInt(x,240,249))

    val getToStern = udf [Option[Int] , String] ( x=> extractInt(x,249,258))

    val getToPort = udf [Option[Int] , String] ( x=> extractInt(x,258,264))

    val getToStarboard = udf [Option[Int] , String] ( x=> extractInt(x,264,270))

    val getPosFixType = udf [Option[Int] , String] ( x=> extractInt(x,270,274))

    val getETAmonth = udf [Option[Int] , String] { x=>
      // 1-12, 0=N/A (default)
      extractInt(x,274,278) match {
        case Some(i) => if(i==0){None}else{Some(i)}
        case None => None
      }
    }

    val getETAday = udf [Option[Int] , String] { x=>
      // 1-31, 0=N/A (default)
      extractInt(x,278,283) match {
        case Some(i) => if(i==0){None}else{Some(i)}
        case None => None
      }
    }
    val getETAhour = udf [Option[Int] , String] { x=>
      // 0-23, 24=N/A (default)
      extractInt(x,283,288) match {
        case Some(i) => if(i==24){None}else{Some(i)}
        case None => None
      }
    }

    val getETAmin = udf [Option[Int] , String] { x=>
      // 0-59, 60=N/A (default)
      extractInt(x,288,294) match {
        case Some(i) => if(i==60){None}else{Some(i)}
        case None => None
      }
    }

    val getDraught = udf [Option[Double] , String] {x=>
      // Meters/10
      extractInt(x, 294,302) match {
        case Some(i) => Some(i / 10.0)
        case None => None
      }
    }

    val getDestination = udf [Option[String] , String] {x=>
      extractString(x, 302,422)
    }

    val getDataTerminalReady = udf [Option[Int], String] {x =>
      extractInt(x, 422, 423)
    }

    import spark.implicits._
    // Filter just messages 5
    // this should be fast as data is partitioned my id
    //
    //  Note, no bit length checks here as:
    //  "it is fairly common in the wild for this message to have a wrong bit
    //  length (420 or 422). Robust decoders should ignore trailing garbage"
    val msg_5_raw = binaryDecodedMessages.where($"id" === 5)

    // For each UDF run it on the dataset.
    msg_5_raw
      .withColumn("repeat_indicator", getRepeat(msg_5_raw("dataBinary")))
      .withColumn("mmsi", getMMSI(msg_5_raw("dataBinary")))
      .withColumn("ais_version", getais_version(msg_5_raw("dataBinary")))
      .withColumn("imo", getIMO(msg_5_raw("dataBinary")) )
      .withColumn("call_sign", getCallSign(msg_5_raw("dataBinary")))
      .withColumn("ship_name", getShipName(msg_5_raw("dataBinary")))
      .withColumn("type_and_cargo", getShipType(msg_5_raw("dataBinary")))
      .withColumn("to_bow", getToBow(msg_5_raw("dataBinary")))
      .withColumn("to_stern", getToStern(msg_5_raw("dataBinary")))
      .withColumn("to_port", getToPort(msg_5_raw("dataBinary")))
      .withColumn("to_starboard", getToStarboard(msg_5_raw("dataBinary")))
      .withColumn("epfd", getPosFixType(msg_5_raw("dataBinary")))
      .withColumn("eta_month", getETAmonth(msg_5_raw("dataBinary")))
      .withColumn("eta_day", getETAday(msg_5_raw("dataBinary")))
      .withColumn("eta_hour", getETAhour(msg_5_raw("dataBinary")))
      .withColumn("eta_min", getETAmin(msg_5_raw("dataBinary")))
      .withColumn("draught", getDraught(msg_5_raw("dataBinary")))
      .withColumn("destination", getDestination(msg_5_raw("dataBinary")))
      .withColumn("data_terminal_ready", getDataTerminalReady(msg_5_raw("dataBinary")))
  }
}
